# Calculator - Personal

## 🗒︎목차
1. [소개](#-소개)
2. [개발환경 및 라이브러리](#-개발환경-및-라이브러리)
3. [팀원](#-팀원)
4. [타임라인](#-타임라인)
5. [UML](#-uml)
6. [실행화면](#-실행-화면)
7. [트러블 슈팅 및 고민](#-트러블-슈팅-및-고민)
8. [참고링크](#-참고-링크)


## 👋 소개
[Kyo](https://github.com/KyoPak)가 구현한 Calculater Step-2 입니다.


## 💻 개발환경 및 라이브러리
[![swift](https://img.shields.io/badge/swift-5.6-orange)]()
[![xcode](https://img.shields.io/badge/Xcode-13.4.1-blue)]()


## 🧑 팀원
<img src = "https://user-images.githubusercontent.com/59204352/187332158-a15815eb-3847-40e5-a6f0-93a373f21180.JPG" width=200 height=170>|
|:--:|
|[Kyo](https://github.com/KyoPak)|
 

## 🕖 타임라인

Step - 2 : 2022.09.23 ~ 09.26

## 🗺 UML
![제목 없는 다이어그램](https://user-images.githubusercontent.com/59204352/191893437-3885c44e-cb43-46e6-aeb6-49a7beb0d05e.jpg)


## 💻 실행 화면 

추후에 추가 예정



## 🎯 트러블 슈팅 및 고민
### Step - 1 
<details>
<summary> 
펼쳐보기
</summary>
   
#### ***1. LinkedList와 Array로 Queue를 구현할 때의 각각의 차이점에 대해서 고민***
- Array는 접근할때 시간복잡도 O(1)으로 매우 빠르기 때문에 탐색기능이 필요할 때는 Array로 구현이 더 적합할 것이라고 판단을 하였습니다. 
- 하지만 가장 앞의 요소를 제거하거나 중간 요소를 제거할 때는 Array의 경우에는 O(n)이고 LinkedList의 경우에는 O(1)으로 head부분만 바꿔주면 되기 때문에 LinkedList가 더욱 적합하다고 생각하였습니다.
- 하지만 Node타입의 적용한 배열을 사용한다면 탐색기능과 삭제기능 모두 좋지 않을까 라는 생각이 추후에 들었습니다.

### ***2. CalcutatorItemQueue와 LinkedList사이의 의존성 문제에 대한 고민***
- 사실 외부에서 CalcutatorItemQueue의 객체를 만들 때 LinkedList 인스턴스를 외부에서 주입하는 방식을 고민했습니다. 
- 하지만 단순히 외부에서 인스턴스, 객체를 주입한다고 해서 의존성이 떨어지는 효과를 기대할수 없다고 생각했습니다. 의존성을 분리해주는 프로토콜이 존재하지 않는 설계를 했기 때문이었습니다.
- 또한, 단순히 의존성을 낮추기 위해 의존성 주입을 사용하는 것이 아닌 얼만큼 CalcutatorItemQueue가 얼만큼 재사용이 되는지에 대한 고민도 같이 해보았을 때 의존성 주입은 불필요하다고 판단하였습니다.
</details>


### Step - 2

#### ***1. 고차함수에 사용에 대한 고민***
- 코드를 구현할 때, 가독성 부분을 신경쓰기 위해서 지나친 열거식 고차함수를 지양하지 않았습니다.
- 고차함수를 적절히 활용한다면 간결하게 표현할 수 있다는 것은 알았지만 왜 고차함수를 지향하는 이유를 알지 못했었습니다.
    - 고차함수는 상수 let으로 함수 내부에서 바로 표현 및 할당이 가능하기 때문에 한번에 표현이 가능하고 SideEffect를 방지할수 있다는 장점을 가지고 있다는 것을 알 수 있었습니다.

#### ***2. 간결한 코드 vs 가독성이 좋은 코드***
- 간결한 코드와 가독성이 좋은 코드의 지향점에 대한 고민을 했습니다. 
    - 간결하게 표현해 줄 수 있는 고차함수 등을 사용한다면 코드의 수는 줄 일 수 있지만 가독성이 떨어질 것이라 생각이 들어 이러한 고민을 했습니다.
    - 실력을 더 쌓은 후, 고민을 다시 해봐야겠지만 현재는 적당한 간결함을 선택하고 높은 가독성을 추구하는게 제일 좋은 코드라고 생각하게 되었습니다. 
      그 이유는 아직 학습자의 입장이라는 점과 유지보수, 협업시에 일어날 문제 때문입니다. 하지만 실제 회사를 간다면 PR을 문서화 해놓기 때문에 간결함을 추구할 수도 있을 것 같습니다..
    
#### ***3. 테스트에 대한 고민***
- 테스트 케이스, 테스트에 필요한 데이터가 나오는 배경에 대해서 고민했습니다.
    - 이 부분에 대해서 리뷰어와 이야기 해본 결과, 
    TDD에서의 테스트, 단순 테스트 모두 실행하는 시점에 대한 고민이 필요하다고 느꼈고, 구현해야 하는 기능을 먼저 생각해봐야겠다고 느꼈습니다.
    
    
## 📚 참고 링크
